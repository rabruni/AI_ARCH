  Control Plane Documentation

  1. Documentation Outline

   1. System Overview
       * 1.1. The Problem: The Unpredictability of Agent-First Systems
       * 1.2. The Solution: A Deterministic, Gate-Enforced Execution Contract
   2. System Architecture
       * 2.1. Components
       * 2.2. Trust Boundaries
       * 2.3. Control Flow: From Intent to Audited Execution
       * 2.4. Artifact Flow
   3. Artifact Reference
       * 3.1. SPEC Packs
       * 3.2. WORK_ITEM.md
       * 3.3. 08_commit.md
       * 3.4. gate_results.json
       * 3.5. validate_work_item.py
       * 3.6. validate_spec_pack.py
       * 3.7. flow_smoke_check.sh
   4. User Guide: Safe Operating Procedure
       * 4.1. Step 1: Explore Intent with the AI Shaper
       * 4.2. Step 2: Refine the Work Item via Questions
       * 4.3. Step 3: Author and Review the WORK_ITEM.md Execution Contract
       * 4.4. Step 4: Commit the Work Item for Execution
       * 4.5. Step 5: Observe G0 Gate Enforcement
       * 4.6. Step 6: Interpret the Outcome
   5. The Human Mental Model
       * 5.1. Why Exploration is Question-Driven, Not Command-Driven
       * 5.2. Why Commitment is an Explicit, Auditable Human Action
       * 5.3. How This Model Prevents AI Drift and False Confidence
   6. The Safety & Trust Model
       * 6.1. Core Principle: Zero Trust for AI
       * 6.2. System Guarantees
       * 6.3. What is Not Guaranteed
       * 6.4. Tamper Detection
   7. Failure Modes & Anti-Patterns
       * 7.1. Anti-Pattern: Bypassing the WORK_ITEM.md
       * 7.2. Anti-Pattern: Over-Scoped Work Items
       * 7.3. Anti-Pattern: Weak or Missing Acceptance Commands
       * 7.4. Anti-Pattern: Confusing EXPLORE vs. COMMIT
       * 7.5. Anti-Pattern: Assuming AI Judgment Replaces Gates
   8. Contributor Guide
       * 8.1. Adding New SPEC Packs
       * 8.2. Extending Validation Safely
       * 8.3. Core Mandate for Contributors

  ---

  2. System Overview

  2.1. The Problem: The Unpredictability of Agent-First Systems
  Autonomous agent systems that directly interpret and execute natural language intent
  are inherently non-deterministic. Their behavior can change based on model version,
  prompt phrasing, or even subtle variations in context, leading to unpredictable
  outcomes. This makes them fundamentally un-auditable and unsafe for tasks requiring
  high reliability and correctness. Such systems often fail silently, produce plausible
  but incorrect work, and drift from the original user's intent without a mechanism to
  enforce alignment. Placing trust in the agent's "understanding" is a recipe for
  systemic risk.

  2.2. The Solution: A Deterministic, Gate-Enforced Execution Contract

  This system inverts the traditional agent model. Instead of trusting an AI to
  interpret and act, it uses AI as a tool to help a human author a deterministic,
  machine-readable execution contract, known as a WORK_ITEM.md.

  The core principles are:

   * Determinism: The WORK_ITEM.md is a precise specification of work, including file
     permissions and acceptance commands. It is the sole source of truth for execution.
     The AI does not interpret this contract; it is executed verbatim by a simple,
     non-intelligent worker.
   * Explicit Commitment: A human must review, approve, and explicitly commit the
     WORK_ITEM.md for execution. This action is a hard boundary, moving from a flexible
     "shaping" phase to a locked "execution" phase.
   * Gate-Enforced Governance: Before any execution occurs, the committed contract is
     validated by a series of deterministic, automated gates. The G0 gate, for
     instance, validates the contract's schema, scope, and hash integrity. If any check
     fails, execution is blocked. No agent can bypass this enforcement.

  This architecture treats the AI as an untrusted client and the human as the
  accountable authority, enabling safe, auditable, and reliable automation.

  ---

  3. System Architecture

  3.1. Components

   * AI Shaper: A front-end, human-facing interface. Its only role is to assist a human
     in drafting a WORK_ITEM.md through a question-driven process. It has no execution
     capabilities.
   * Human Operator: The engineer, lead, or auditor who uses the AI Shaper, reviews the
     WORK_ITEM.md, and makes the explicit decision to commit it for execution.
   * Control Plane: The deterministic, automated core of the system. It contains no
     LLMs. Its sole purpose is to receive a committed WORK_ITEM.md and enforce all
     validation and execution rules via the gate system.
   * Gates (e.g., G0): A series of non-negotiable, programmatic checkpoints within the
     Control Plane. G0 is the primary commit-time gate that validates the execution
     contract's correctness and integrity.
   * Worker Agents: Simple, non-intelligent script runners. They are treated as
     untrusted and are only activated after a contract successfully passes the G0 gate.
     Their only function is to execute the steps defined in the WORK_ITEM.md verbatim.

  3.2. Trust Boundaries

   * Untrusted Zone: Contains the AI Shaper and the Worker Agents. These components are
     assumed to be fallible and are never given authority. The AI Shaper cannot execute
     commands; the Worker Agent cannot define its own tasks.
   * Human-in-the-Loop: The human operator is the source of authority, responsible for
     reviewing and committing the execution contract.
   * Trusted Computing Base (TCB): The Control Plane and its gate system. This is the
     only part of the system that is trusted to enforce rules correctly. It is designed
     to be minimal, deterministic, and easily auditable.

  3.3. Control Flow: From Intent to Audited Execution

   1. Shaping (Human & AI): The Human Operator uses the AI Shaper to explore an intent.
      The AI asks clarifying questions and helps draft a WORK_ITEM.md. This is an
      iterative, non-binding process.
   2. Commitment (Human): The Human Operator finalizes and reviews the WORK_ITEM.md.
      Satisfied with the contract, they issue a commit command, signaling their intent
      to execute.
   3. Enforcement (Control Plane): The commit action triggers the Control Plane. The G0
      gate is invoked automatically.
   4. Validation (G0 Gate): G0 performs a series of checks:
       * It verifies the commit is in MODE=COMMIT.
       * It calculates the SHA256 hash of the WORK_ITEM.md.
       * It validates the contract's schema, scope, and acceptance criteria using
         validate_work_item.py.
       * It compares the hash to previous runs to detect tampering.
   5. Execution Block (Default): If any G0 check fails, the process stops. An error is
      logged, and no execution occurs.
   6. Execution Dispatch (Control Plane): If G0 passes, the Control Plane dispatches
      the validated WORK_ITEM.md to a Worker Agent.
   7. Execution (Worker): The Worker Agent executes the Implementation Plan and
      Acceptance Commands from the WORK_ITEM.md verbatim. It has no autonomy to
      deviate.
   8. Auditing: The output of the G0 gate, including the work item's hash, is stored in
      gate_results.json, creating an immutable audit trail linking the commitment to
      the exact code that was validated.

  3.4. Artifact Flow

   * The Human Operator produces a WORK_ITEM.md and an 08_commit.md.
   * These are consumed by the Control Plane's G0 Gate.
   * G0 uses validate_work_item.py to validate the WORK_ITEM.md.
   * Upon completion, G0 produces a gate_results.json containing the validation status
     and evidence.
   * If G0 passes, the WORK_ITEM.md is consumed by a Worker Agent.

  ---

  4. Artifact Reference


  ┌────┬─────────────────────────────┬───────┬─────┬───────────────────────────────────
  ───┐
  │ Ar │ Purpose                     │ Au... │ Con │ Enforcement Mechanism
  │
  ├────┼─────────────────────────────┼───────┼─────┼───────────────────────────────────
  ───┤
  │ ** │ A structured unit defini... │ Human │ Con │ validate_spec_pack.py ensures
  struc... │
  │ ** │ A deterministic executio... │ Hu... │ G0  │ validate_work_item.py (invoked by
  G... │
  │ ** │ A machine-readable file ... │ Human │ G0  │ G0 Gate parses this file and
  bloc... │
  │ ** │ An immutable, auditable ... │ G0... │ Aud │ flow_smoke_check.sh consumes this
  f... │
  │ ** │ A deterministic script t... │ Hu... │ G0  │ G0 Gate executes this script. A
  n... │
  │ ** │ A script that validates ... │ Hu... │ CI/ │ Executed by higher-level gates
  (e... │
  │ ** │ A CI script that runs a ... │ Hu... │ CI/ │ It executes a test flow and
  valid... │
  └────┴─────────────────────────────┴───────┴─────┴───────────────────────────────────
  ───┘

  ---

  5. User Guide: Safe Operating Procedure

  This guide outlines the standard, safe workflow for using the system.

  5.1. Step 1: Explore Intent with the AI Shaper

  Begin by describing your high-level goal to the AI Shaper. Treat this as a
  brainstorming and requirements-gathering phase. The AI is a tool to help you think,
  not an oracle to command.

  5.2. Step 2: Refine the Work Item via Questions

  The AI Shaper will ask clarifying questions to break down your intent into the
  structured format of a WORK_ITEM.md. Answer these questions to define the precise
  scope, implementation steps, and, most importantly, the Acceptance Commands that will
  prove the work is complete and correct.

  5.3. Step 3: Author and Review the WORK_ITEM.md Execution Contract

  The output of the shaping process is a WORK_ITEM.md file. You, the human, are the
  author and final authority. Review this file with extreme care.
   * Is the Objective clear and singular?
   * Is the Scope: File Permissions list minimal and correct?
   * Is the Implementation Plan a simple, verifiable series of steps?
   * Are the Acceptance Commands deterministic and sufficient to prove success?

  You are responsible for the correctness of this contract.

  5.4. Step 4: Commit the Work Item for Execution

  Once you are fully satisfied with the WORK_ITEM.md, create or update the 08_commit.md
  file. Set MODE=COMMIT and ensure the REFERENCES section points to your WORK_ITEM.md.
  Committing this file to the repository is the explicit, auditable signal that you are
  authorizing execution.

  5.5. Step 5: Observe G0 Enforcement

  Upon commit, the Control Plane will automatically trigger. Observe the CI/CD
  pipeline. The G0 gate will run, validating your committed contract. It will calculate
  the file's hash, check its schema, and run all validation rules. This is not optional
  and cannot be bypassed.

  5.6. Step 6: Interpret the Outcome

   * If G0 Fails: Execution is blocked. Read the gate_results.json or CI logs to
     understand why. The failure is a safety feature. Return to Step 3 to correct the
     WORK_ITEM.md.
   * If G0 Passes: The system has validated your intent. A worker agent will now
     execute the contract. Monitor the output of the worker and the Acceptance Commands
     to confirm the final result.

  ---

  6. The Human Mental Model

  6.1. Why Exploration is Question-Driven

  The system forces a question-driven interaction during the shaping phase to prevent
  ambiguity. Free-form commands to an LLM hide assumptions. A structured Q&A process
  makes assumptions explicit, ensuring the resulting WORK_ITEM.md is a precise
  reflection of a well-understood task, not a guess at a vague instruction.

  6.2. Why Commitment is Explicit

  Execution is a high-stakes action. The system requires an explicit, auditable git
  commit action to move from the "soft" world of planning to the "hard" world of
  execution. This prevents accidental execution and creates a clear line of
  accountability. The person who commits the WORK_ITEM.md is authorizing the action.

  6.3. How This Model Prevents AI Drift and False Confidence

  AI models can produce confident but incorrect outputs ("hallucinations") and can
  drift from the original intent over long conversations. This system mitigates that
  risk entirely:
   * The AI's output is just a draft (WORK_ITEM.md), not an action.
   * The human is forced to review and own this draft.
   * The G0 gate and Acceptance Commands are objective, programmatic checks that do not
     depend on the AI's "confidence."

  The system trusts code and verifiable artifacts, not the persuasive prose of an LLM.

  ---

  7. The Safety & Trust Model

  7.1. What is Not Trusted

   * LLMs / AI: The AI Shaper is treated as an untrusted, fallible client. Its output
     is always subject to human review and programmatic validation.
   * Worker Agents: The agents that execute the work are simple script runners with no
     autonomy. They are not trusted to make decisions.
   * User Intent: Natural language intent is not trusted. It must be refined into a
     deterministic, machine-validated contract (WORK_ITEM.md).

  7.2. System Guarantees

   * Execution Lock: No code or task can be executed by a worker agent without first
     passing the G0 gate.
   * Integrity: The WORK_ITEM.md that is executed is cryptographically identical to the
     one the human reviewed and the G0 gate validated.
   * Auditability: Every execution attempt generates an immutable audit record
     (gate_results.json) linking the human's commit, the G0 validation result, and the
     hash of the work item.
   * Scope Enforcement: The validate_work_item.py script ensures that the WORK_ITEM.md
     does not grant permissions to modify forbidden or critical system files.

  7.3. What is Not Guaranteed

   * Correctness of Intent: The system guarantees that it executes the WORK_ITEM.md
     correctly. It does not guarantee that the WORK_ITEM.md correctly achieves the
     user's high-level business goal. The human author is accountable for the
     correctness of the contract.
   * Flawless Worker Execution: While the worker is simple, it still relies on an
     underlying execution environment. The system does not guarantee that the
     environment itself (e.g., network, filesystem) is free of transient errors.

  7.4. Tamper Detection

  The G0 gate computes a SHA256 hash of the WORK_ITEM.md upon commit. This hash is
  stored as part of the evidence. The system is designed to compare this hash against
  previously recorded hashes for the same work item, failing the gate if a mismatch is
  detected. This prevents a scenario where a work item is validated, then tampered with
  before execution.

  ---

  8. Failure Modes & Anti-Patterns

  8.1. Anti-Pattern: Bypassing the WORK_ITEM.md
   * Action: A developer attempts to add logic directly to a worker agent or commit
     code without a corresponding execution contract.
   * Why it Fails: The system's control flow is locked. The Control Plane only
     dispatches tasks specified in a G0-validated WORK_ITEM.md. Any other code
     committed will not be executed by the managed worker system.

  8.2. Anti-Pattern: Over-Scoped Work Items
   * Action: An author creates a WORK_ITEM.md with an overly broad objective or grants
     MODIFIABLE access to dozens of files.
   * How the System Exposes It: While not a hard block, this is a procedural failure.
     The human review step is the primary defense. An auditor or peer reviewer should
     immediately flag a large or complex WORK_ITEM.md as too risky, demanding it be
     broken into smaller, more verifiable units.

  8.3. Anti-Pattern: Weak or Missing Acceptance Commands
   * Action: A WORK_ITEM.md is authored with Acceptance Commands that are trivial
     (e.g., echo "done") or non-existent.
   * How the System Blocks It: The validate_work_item.py script, executed by G0, fails
     the validation if the Acceptance Commands section is empty or does not contain at
     least one actual command. This ensures every work item has a programmatic
     definition of success.

  8.4. Anti-Pattern: Confusing EXPLORE vs. COMMIT
   * Action: A user leaves MODE=EXPLORE in 08_commit.md and expects their work to be
     executed.
   * How the System Blocks It: The G0 gate reads 08_commit.md and will
     deterministically fail if MODE is not COMMIT, with a clear message that execution
     is blocked. This is a fundamental safety lock.

  8.5. Anti-Pattern: Assuming AI Judgment Replaces Gates
   * Action: A user trusts the AI Shaper when it says a WORK_ITEM.md is "correct" and
     commits it without proper personal review.
   * How the System Exposes It: If the AI-generated contract is flawed (e.g., has a
     syntax error, a forbidden file path, or no acceptance tests), G0 will fail. The
     system's programmatic gates are the objective authority, not the AI's
     conversational output.

  ---

  9. Contributor Guide

  9.1. Adding New SPEC Packs
  When adding a new specification, ensure it follows the established structure. It must
  include 07_registry.md to declare artifacts and 05_testing.md with a command to
  validate the spec's integrity. Add a corresponding check to flow_smoke_check.sh to
  ensure your new spec is continuously validated.

  9.2. Extending Validation Safely
  If you need to add a new validation rule, modify the appropriate validation script
  (e.g., validate_work_item.py). Ensure your new check is deterministic, returns a
  non-zero exit code on failure, and is accompanied by a new negative test case in
  flow_smoke_check.sh to prove it works.

  9.3. Adding Tests Without Weakening Guarantees
  When adding tests to flow_smoke_check.sh, ensure they are specific and assertive. A
  good test checks for the presence of correct evidence in a PASS case and the presence
  of a specific failure reason in a FAIL case. Avoid tests that just check for a zero
  exit code, as they can create silent pass paths.

  9.4. Core Mandate for Contributors
  You must never do any of the following:
   * Introduce LLM calls or any non-deterministic logic inside the Control Plane.
   * Allow any execution path to bypass the G0 commit gate.
   * Weaken the validation logic in validate_work_item.py or other gate-enforced
     scripts.
   * Approve a change that does not have a corresponding update to the smoke tests to
     verify its enforcement.
